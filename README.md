# ysl
8583ysl  
ysl8583 实现了基本的ISO8583协议,适用于银联pos报文规范,当前版本只支持基本的64bit位图的字段域。
### 格式
> 长度

报文长度校验使用，长度包括报文头（定长11bytes），消息类型（定长2bytes），位图（8bytes）以及报文体的长度之和，以2字节16进制数表示。例：
```
报文长度100
2字节16进制长度 0064
```
> 报文头格式

TPDU | 报文头
---|---
ID(60H)，目的地址（NN NN），原地址（NN NN） | 应用类别定义（N2），软件版本号（N2），终端状态（N1）,处理要求（N1）,保留使用（N6）


tpdu 定长10字节bcd码，压缩表5字节长度的数值。   
报文头 定长12字节bcd码，压缩表6字节长度的数值。
> 消息类型

2字节16进制数表示消息类型。例：
```
0200 消费交易 0210 消费返回
```
> 位图

8 位16进制数表示64位bit位图，可通过bytes2bin手动计算位图：
```
byte[] bytes = {-1, -96};
ByteUtil.bytes2bin(bytes);
结果：
1111111110100000
```
> 报文体

16进制数表示字母，数字，特殊字符，二进制bit，磁道编码等。
### 基本用法
#### 配置文件 8583_config.properties
- String.
- 长度
- 数据类型

> 数据长度

值 |描述
---|---
number | 定长
VAR2 | 2字节bcd码表长度，压缩成1字节
VAR3 | 3字节bcd码表长度，压缩成2字节


> 数据类型

值 | 描述
---|---
bcd | 8421 bcd码，数字域，定长右靠左补零
ascii | ascii码，表示数字，字母，字符，定长左靠右补零
tlv | 55域 tlv数据
zzz | 35域，36域 磁道数据

> 补充

某些规范在配置文件中无法体现，在程序中已经做出了限制，如2磁和3磁的最大长度定义。

#### 报文解包
```
Map<String,String> map = PosDecoder.getInstance().parse("0143600688000060400018042402007024068020C082311662580000000001960000000000000000020013692704072000010020376258000000000196D270420100000853000000373630303035363334323333333230373932393232303131353601519F2608B1AAD1CB0083B5029F2701809F101307010103A00000040A01000000000095DE79D39F370486F5FD329F36020289950500000000009A031902279C01009F02060000000000025F2A02015682027C009F1A0201569F3303E0F0C89F3501228408A0000003330101029F090200209F6310303432333333313000000000000000009F1E0838343731343637339F03060000000000000055413230353001023034021030303030303130343834373134363733030630303031393604084645434339463032050831383034323420200014220000030006014146433431454230");
System.out.println(map.toString());

结果：
{FIELD002=6258000000000196, FIELD003=000000, FIELD004=000000000002, FIELD011=001369, FIELD014=2704, FIELD022=0720, FIELD023=0001, FIELD025=00, FIELD035=6258000000000196=270420100000853000000, FIELD041=76000563, FIELD042=423332079292201, FIELD049=156, FIELD055={tag=[9f26]length=[8]value=[b1aad1cb0083b502]}{tag=[9f27]length=[1]value=[80]}{tag=[9f10]length=[19]value=[07010103a00000040a01000000000095de79d3]}{tag=[9f37]length=[4]value=[86f5fd32]}{tag=[9f36]length=[2]value=[0289]}{tag=[95]length=[5]value=[0000000000]}{tag=[9a]length=[3]value=[190227]}{tag=[9c]length=[1]value=[00]}{tag=[9f02]length=[6]value=[000000000002]}{tag=[5f2a]length=[2]value=[0156]}{tag=[82]length=[2]value=[7c00]}{tag=[9f1a]length=[2]value=[0156]}{tag=[9f33]length=[3]value=[e0f0c8]}{tag=[9f35]length=[1]value=[22]}{tag=[84]length=[8]value=[a000000333010102]}{tag=[9f09]length=[2]value=[0020]}{tag=[9f63]length=[16]value=[30343233333331300000000000000000]}{tag=[9f1e]length=[8]value=[3834373134363733]}{tag=[9f03]length=[6]value=[000000000000]}, FIELD059=A2050040000010484714673000196FECC9F02180424  , FIELD060=22000003000601, FIELD064=4146433431454230, bitmap=0111000000100100000001101000000000100000110000001000001000110001, head=604000180424, mti=0200, tpdu=6006880000}
```
#### 报文装包
```
HashMap<String,String> map = new HashMap<>();
        map.put("tpdu","6006880000");
        map.put("mti","0200");
        map.put("head","604000180424");
        map.put("FIELD042","423332079292201");
        map.put("FIELD041","76000563");
        map.put("FIELD002","6258000000000253");
        map.put("FIELD003","000000");
        map.put("FIELD048","999");
        map.put("FIELD004","000000000115");
        map.put("FIELD011","001726");
        map.put("FIELD014","2704");
        map.put("FIELD035","6258000000000253132704201000004760000");
        map.put("FIELD038","001926");
        map.put("FIELD049","156");
        map.put("FIELD060","2000000400060");
        map.put("FIELD061","0000000000000302");
        map.put("FIELD062","金杰是我aa!@#");
        System.out.println(PosEncoder.getInstance().encode(map));;
结果：
008b600688000060400018042402007024000024c1801c1662580000000002530000000000000001150017262704203762580000000002531327042010000047600000303031393236373630303035363334323333333230373932393232303100030999313536001302000000400060001600000000000003020017e98791e69db0e698afe688916161214023
```
#### 55域装包
```
Map<String,String> map = new HashMap<>();
        map.put("9F26","B1AAD1CB0083B502");
        map.put("9F27","80");
        map.put("9F10","07010103A00000040A01000000000095DE79D3");
        map.put("9F37","86F5FD32");
        map.put("9F1E","84714622");
        System.out.println(TlvEncoder.encode(map));
结果：
9F101307010103A00000040A01000000000095DE79D39F2701809F2608B1AAD1CB0083B5029F370486F5FD329F1E083834373134363232
```
#### 55域解包
```$xslt
 String msg = "9F101307010103A00000040A01000000000095DE79D39F2701809F2608B1AAD1CB0083B5029F370486F5FD329F1E083834373134363232";
        List<TagLengthValue> list = TlvDecoder.parse(ByteUtil.hex2bytes(msg));
        Iterator<TagLengthValue> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next().toString());
        }
结果：
{tag=[9f10],length=[19],value=[07010103a00000040a01000000000095de79d3]}
{tag=[9f27],length=[1],value=[80]}
{tag=[9f26],length=[8],value=[b1aad1cb0083b502]}
{tag=[9f37],length=[4],value=[86f5fd32]}
{tag=[9f1e],length=[8],value=[3834373134363232]}
```